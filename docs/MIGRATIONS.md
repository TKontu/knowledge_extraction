# Database Migrations with Alembic

This document explains how to work with database migrations in the Knowledge Extraction pipeline using Alembic.

## Overview

The project uses Alembic for database schema migrations, replacing the previous `init.sql` approach. This provides:

- **Version control** for database schema
- **Safe schema evolution** with rollback capability
- **Automatic migration** on deployment
- **Audit trail** of all schema changes

## Migration Files Location

```
src/
├── alembic/
│   ├── versions/           # Migration scripts (version controlled)
│   │   ├── 20260110_001_initial_schema.py
│   │   └── 20260110_002_seed_builtin_profiles.py
│   ├── env.py              # Alembic environment configuration
│   └── script.py.mako      # Template for new migrations
├── alembic.ini             # Alembic configuration file
└── orm_models.py           # SQLAlchemy models (source of truth)
```

## Automatic Migration on Deployment

Migrations run automatically when deploying with Docker Compose:

```bash
docker compose up
```

The `migrate` service runs before the `pipeline` service starts, ensuring the database schema is always up-to-date.

## Manual Migration Commands

### Apply Migrations

```bash
# Run all pending migrations (recommended)
# Commands now run from repo root
python -m alembic upgrade head

# Apply specific migration
python -m alembic upgrade 002

# Apply one migration at a time
python -m alembic upgrade +1
```

### Rollback Migrations

```bash
# Rollback one migration
python -m alembic downgrade -1

# Rollback to specific version
python -m alembic downgrade 001

# Rollback all migrations
python -m alembic downgrade base
```

### Check Migration Status

```bash
# Show current version
python -m alembic current

# Show migration history
python -m alembic history --verbose

# Show pending migrations
python -m alembic heads
```

## Creating New Migrations

### 1. Automatic Generation (Recommended)

After modifying `orm_models.py`, generate a migration:

```bash
# Commands now run from repo root
python -m alembic revision --autogenerate -m "add_user_preferences_column"
```

**Important:** Always review autogenerated migrations! Alembic may miss:
- Column renames (detects as drop + add)
- Data type changes that need data migration
- Complex constraints

### 2. Manual Migration (For Data Migrations)

Create an empty migration template:

```bash
# Commands now run from repo root
python -m alembic revision -m "migrate_user_data"
```

Then edit the generated file in `alembic/versions/` to add your migration logic.

### Example Data Migration

```python
"""migrate_user_data

Revision ID: 003
Revises: 002
"""
from alembic import op
import sqlalchemy as sa


def upgrade() -> None:
    # Add new column
    op.add_column('users', sa.Column('full_name', sa.String(), nullable=True))

    # Migrate data
    op.execute("""
        UPDATE users
        SET full_name = first_name || ' ' || last_name
        WHERE first_name IS NOT NULL AND last_name IS NOT NULL
    """)

    # Make column non-nullable after data migration
    op.alter_column('users', 'full_name', nullable=False)


def downgrade() -> None:
    op.drop_column('users', 'full_name')
```

## Development Workflow

### Adding a New Table

1. **Update ORM model** in `orm_models.py`:
   ```python
   class NewTable(Base):
       __tablename__ = "new_table"
       id: Mapped[uuid.UUID] = mapped_column(UUID, primary_key=True, default=uuid4)
       name: Mapped[str] = mapped_column(Text, nullable=False)
   ```

2. **Generate migration**:
   ```bash
   # Commands now run from repo root
   python -m alembic revision --autogenerate -m "add_new_table"
   ```

3. **Review the generated migration** in `alembic/versions/`

4. **Test locally**:
   ```bash
   # Apply migration
   python -m alembic upgrade head

   # Test rollback
   python -m alembic downgrade -1

   # Re-apply
   python -m alembic upgrade head
   ```

5. **Commit migration file**:
   ```bash
   git add alembic/versions/
   git commit -m "Add new_table migration"
   ```

### Adding a Column

1. **Update ORM model**:
   ```python
   class ExistingTable(Base):
       # ... existing fields ...
       new_field: Mapped[str] = mapped_column(Text, nullable=True)
   ```

2. **Generate and review migration**:
   ```bash
   python -m alembic revision --autogenerate -m "add_new_field_to_existing_table"
   ```

3. **Test and commit** as above

## Docker Deployment

### Fresh Deployment

```bash
# Start all services (migrations run automatically)
docker compose up -d

# Check migration logs
docker compose logs migrate
```

### Updating Existing Deployment

```bash
# Pull latest code with new migrations
git pull

# Rebuild and restart (migrations run automatically)
docker compose up -d --build

# Verify migration status
docker compose exec pipeline python -m alembic current
```

### Manual Migration in Docker

If you need to run migrations manually:

```bash
# Run migration in running container
docker compose exec pipeline python -m alembic upgrade head

# Or run one-off migration container
docker compose run --rm migrate
```

## Testing Migrations

### Test Upgrade Path

```bash
# Start from clean database
docker compose down -v
docker compose up postgres -d

# Wait for postgres to be ready
sleep 5

# Run migrations
docker compose run --rm migrate

# Verify all tables exist
docker compose exec postgres psql -U scristill -d scristill -c '\dt'
```

### Test Downgrade Path

```bash
# Rollback all migrations
docker compose exec pipeline python -m alembic downgrade base

# Verify tables are dropped
docker compose exec postgres psql -U scristill -d scristill -c '\dt'

# Re-apply migrations
docker compose exec pipeline python -m alembic upgrade head
```

## Configuration

### Environment Variables

Alembic reads the database URL from the `DATABASE_URL` environment variable:

```bash
# Local development
export DATABASE_URL="postgresql://scristill:scristill@localhost:5432/scristill"

# Docker (automatic)
DATABASE_URL=postgresql://scristill:scristill@postgres:5432/scristill
```

### Alembic Configuration

`alembic.ini` is configured to:
- Use `alembic/` directory for migrations
- Generate timestamped migration filenames
- Run `ruff format` on generated files (if available)
- Use settings from environment

## Troubleshooting

### Migration Fails with "Relation Already Exists"

Your database already has tables from `init.sql`. Options:

1. **Fresh start** (development only):
   ```bash
   docker compose down -v
   docker compose up -d
   ```

2. **Stamp current version** (mark migration as applied without running):
   ```bash
   python -m alembic stamp head
   ```

### Migration Out of Sync

If migrations don't match database state:

```bash
# Check current version
python -m alembic current

# Force stamp to specific version
python -m alembic stamp 001

# Then upgrade
python -m alembic upgrade head
```

### Rollback Failed

If downgrade fails, you may need to manually fix the database:

```bash
# Connect to database
docker compose exec postgres psql -U scristill -d scristill

# Manual fixes here

# Update alembic version table
UPDATE alembic_version SET version_num = '001';
```

## Best Practices

1. **Always review autogenerated migrations** - they may not be perfect
2. **Test migrations in development first** - verify upgrade and downgrade
3. **Keep migrations small and focused** - one logical change per migration
4. **Never modify applied migrations** - create a new migration instead
5. **Commit migrations with code changes** - keep schema and code in sync
6. **Use descriptive migration names** - make purpose clear
7. **Handle data carefully** - plan data migrations for schema changes
8. **Test rollback paths** - ensure downgrades work correctly

## Migration Naming Convention

Migrations use timestamped filenames:

```
YYYYMMDD_HHMM_<revision>_<description>.py
```

Examples:
- `20260110_001_initial_schema.py`
- `20260110_002_seed_builtin_profiles.py`
- `20260115_1430_a1b2c3d4_add_user_preferences.py`

## ORM Models as Source of Truth

The SQLAlchemy ORM models in `orm_models.py` define the schema. Always:

1. Update ORM models first
2. Generate migration from models
3. Review and test migration
4. Commit both model changes and migration

Never manually edit the database schema - always use migrations.

## Production Considerations

For production deployments:

1. **Backup database** before applying migrations
2. **Test migrations** in staging environment
3. **Plan downtime** for complex migrations
4. **Monitor migration logs** during deployment
5. **Have rollback plan** ready
6. **Use database replicas** for zero-downtime migrations (advanced)

## Resources

- [Alembic Documentation](https://alembic.sqlalchemy.org/)
- [SQLAlchemy Documentation](https://docs.sqlalchemy.org/)
- Project: `docs/TODO_migrations.md` - Migration implementation plan
